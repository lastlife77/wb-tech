package main

import (
	"fmt"
	"math/rand"
	"time"
)

// канал в go представляет собой следующую структуру(go/src/runtime/chan.go):
// type hchan struct {
//     qcount   uint           // количество элементов в буфере
//     dataqsiz uint           // размер кольцевого буфера
//     buf      unsafe.Pointer // указатель на буфер данных
//     elemsize uint16         // размер одного элемента
//     closed   uint32         // флаг закрытого канала
//     timer    *timer         // таймер для временных каналов
//     elemtype *_type         // тип элемента канала
//     sendx    uint           // индекс для записи в буфер
//     recvx    uint           // индекс для чтения из буфера
//     recvq    waitq          // очередь ожидающих получателей
//     sendq    waitq          // очередь ожидающих отправителей
//     lock     mutex          // мьютекс для синхронизации
// }

// recvq и sendq - это списки горутин ожидающих получние или запись
// они представляют собой следующую структуру:
// type waitq struct {
// 	first *sudog	// первая горутина в очереди
// 	last  *sudog	// последняя горутина в очереди
// }

// горутины в очередях представлены следующей структурой(go/src/runtime/runtime2.go):
// type sudog struct {
//     g          *g             // указатель на горутину
//     next       *sudog         // следующий элемент в списке
//     prev       *sudog         // предыдущий элемент в списке
//     elem       unsafe.Pointer // данные для передачи
//     c          *hchan         // канал, на котором заблокирована горутина
//     ...
// }

func asChan(vs ...int) <-chan int {
	c := make(chan int)
	go func() {
		for _, v := range vs {
			// если есть ожидающий получатель,
			// то есть recvq не пуст,
			// то значение записывается в память,
			// на которую указывает sudog.elem
			// и горутина получателя разблокируется,
			// а если нет, то создается отправитель типа sudog,
			// его поле elem указывает на переменную,
			// из которую нужно получить значение,
			// горутина блокируется и указатель на неё записывается в поле g,
			// указатель на канал записываетс в поле c.
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}
	}()
	return c
}

func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	go func() {
		for {
			select {
			// если есть ожидающий отправитель,
			// то есть sendq не пуст,
			// то значение переменной,
			// на которую указывает sudog.elem
			// копируется в переменную получателя
			// и горутина отправителся разблокируется,
			// а если нет, то создается получатель типа sudog,
			// его поле elem указывает на переменную,
			// в которую нужно записать,
			// горутина блокируется и указатель на неё записывается в поле g,
			// указатель на канал записываетс в поле c.
			case v, ok := <-a:
				if ok {
					c <- v
				} else {
					a = nil
				}
			case v, ok := <-b:
				if ok {
					c <- v
				} else {
					b = nil
				}
			}
			if a == nil && b == nil {
				close(c)
				return
			}
		}
	}()
	return c
}

func main() {
	// a - указатель на канал
	// горутина функции asChan работает параллельно с главной горутиной
	// и записывает числа 1, 3, 5, 7 в канал a
	a := asChan(1, 3, 5, 7)
	// b - указатель на канал
	// горутина функции asChan работает параллельно с главной горутиной
	// и записывает числа 2, 4, 6, 8 в канал b
	b := asChan(2, 4, 6, 8)
	// c - указатель на канал
	// горутина функции merge работает параллельно с главной горутиной
	// и читает данные из каналов a и b и записывает в канал c
	c := merge(a, b)
	// чтение из канала c и вывод в главной горутине
	for v := range c {
		fmt.Print(v)
	}
}
